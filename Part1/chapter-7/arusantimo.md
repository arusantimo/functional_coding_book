# 7. 신뢰할수 없는 코드쓰면서 불변성 지키기

## 방어적 복사

카피 온 라이트 !== 방어적 복사

암시적인 데이터를 순수함수에서 다루기 위해선 방어적 복사를 통해

원본의 변경을 방어해야함.

API 통신에서 JSON등으로 데이터를 주고 받을때에도 우리는 방어적 복사를 하고 있음.

### 함수형 프로그래밍에서 데이터

데이터는 이벤트에 대한 사실.

기록을 해야 할때마다 복사가 이뤄질수 있다.

### 카피 온 라이브 !== 방어적 복사

가장큰 차이점
> 깊은 복사나 얕은 복사의 차이가 아닌. 안전 지대와 비안전 지대를 통과할때는 방어적 복사를 사용해야함.
> 가장큰 예시 db >-< be  be >-< fe API 통신에서의 예시
> 통제 되지 않은 외부로 부터의 인풋 아웃풋은 모두 방어적 복사를 하자.

!! 방어적 복사라고 해서 모든 것을 복사할 필요 없다.

`얕은 복사` > 객체의 속성 참조(주소)를 복사함  
ex) const list = [...List];

`방어적 복사 `> 객체의 속성을 복사한다. (선택적으로 복사 가능) !! 핵심 외부로 부터 안전지대의 데이터를 방어하기 위함이다.  
ex) const list = new List(); // 리스트의 방어적 복사라고 할수 있음.

`깊은 복사` > 객체 자체를 재귀를 통해 모두 복사함. (키, 값) 아예 새로운 객체임.  
ex) let list = []; for i of List > list.push(i) > 안에 뎁스 있으면 재귀    



!! 리액트에서는 참조 주소 변경을 통해 랜더링 하는 방식이기 때문에, 만약 랜더링을 위해서라면, 새로운 값인데 다른 주소더라도, 값은 값이여도 재 랜더링 되는것을 볼수 있다.
이런 방식 때문에, API로 넘어온 값을 Props이나 State로 넘겨주고 주소가 바뀌지 않게 해줌으로써 랜더링 성능 최적화 시켜줄수 있음.
