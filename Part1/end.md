### 적용 사례 (부수효과 순수함수 로직을 기존 코드에서 분리)

비지니스 로직를 분리하여 유지보수 효율을 올리기

이전에 작업했던 거래소 사이트의 문제.

자주 바뀌는 거래소 내부 정책 즉 비지니스 로직을 위해 빈번하게 코드 수정을 했어야 했고, 

영향을 받는 수많은 곳에서 체크를 해줬어야 함.

------

현재 내가 만약 새로운 개발자로 들어와서 이런 문제를 해결하고자 한다면,

일단 2단계로 기능적인 코드 레벨을 나눠서 관리하도록 리팩토링할것임.

1.(자주 바뀌는 거래소 정책 => 비지니스 로직)  
2.(거래소 기능 자체를 유지하는 거래소 기본 로직)

물론 1단계에 의해서 2단계도 바뀌어야 하는 상황이 생길수 있다. 가령 
어떤 사용자는 거래를 얼만큼 하면 거래를 일수 중지 해야한다. 이런 기능이 필요로 한다면,
2번도 수정되어 있었다. 하지만 내가 리팩토링한다면, 2번은 1차적인 동작 결과를 리턴하고, 
1번이 그 동작 결과를 이용해서 새로운 로직을 합쳐져 동작 결과를 변화시켜 리턴해야한다.

그래서 무조건 사용자가 만나게될 결과는 1번에 의한 동작 결과여야 하게 바꿀것이다.

2번, 1번 모두 팀적으로 관리해야 하지만 2번의 경우 엄격하게 관리 되도록 개발자 끼리 합의하고

인터페이스등 추상화 레벨을 높게 하여 팀적으로 잘 활용할수 있도록 유도 한다.

또한 1번의 경우 자주 바뀌어야 하는 상황이 많으므로 바뀌더라도 다른 코드에 영향을 가지 않도록 출력하는곳을 

함수에 명시하도록 해서 (혹은 IDE 활용) 코드 수정에 의해 사이드이팩트가 일어나지 않도록 유의 한다.

기대 효과.

---

가정) 이렇게 하여, 빈번하게 바뀌는 거래소 룰에 대한 개발팀의 대응 속도가 상승하고, 사이드 이팩트도 현저하게 줄어 들었다.
또한 새로운 개발자가 합류해도 2번 부터 1번으로 이어지는 코드 레벨의 전파를 통해 빠르게 로직을 분석할수 있었다.




### 적용사례 . 너무 커저버린 전역 상태 문제

(카펜터)데이터 분석 툴을 개발하는 곳에 합류 하게 되었음.

그때 가장큰 문제는 전역 상태가 너무 컸다는 것이다.

그리고 전역 상태에 따라 로직의 결과가 달라져야 하는 경우가 많았음. 

뷰잉만을 위한 것이라면 괜찮지만 전역상태와 그에 따른 파생 상태(컴퓨티드)를 
인자를 받아 처리하는 로직도 존재 했었음..

그렇게 되면 결과를 핸들링 하기 너무 힘듬.

그리고 사용자가 원하는 서비스를 위한 상태가 아닌 모든 전역 상태를 다 가지고 있어서

불필요한 리소스를 소모하고 있다는 점도 문제라고 생각됨

하지만 근거도 존재했었음. 다루는 데이터의 양이 너무 컸기 때문에, 지역 상태를 위해 요청을

자주하거나, 전역상태의 역할 즉, 뷰잉을 위해 알아야 하는 정보양이 많아야 했기 때문이기도 했음.
 
------

내가 이런 문제를 해결한다고 한다면...

우선. 화면 별로 필요로 하는 전역 상태와 파생상태를 엔티티와 컴포넌트 다이어그램으로 정의한다.

그리면 어떤 데이터가 필요로 하는지 화면별로 정의가 되므로 지역 상태로 묶어 줄수가 있다.

전역 상태가 무조건 필요한 케이스를 위해서 꼭 필요한 전역상태에 대한 다이어그램도 정의한다.

그래서 필요한 전역 상태만 응답 받아 저장하도록 한다.

데이터 안에서도 사용 빈도와 필요 여부에 따라 레벨을 나눠 전역 지역으로 분리하고, 요청도 앱실행, 해당 라우터 진입등

으로 분류한다.

그리고 데이터 양이 너무 많아진다면 데이터 청킹하거나 스트림 처리를해야 한다. 모든 데이터를 다 받는데 너무 많은   시간을 소비하면

유저가 떠날수 있다. 

----
가정) 이렇게 하면서, 초기 요청 데이터 양을 현저하게 줄일 수 있어서,  컴포넌트 로딩 속도를 높일수 있었다. 또 전역상태를 모두가 같이 관리하지 않고,
전역 상태의 범위가 작아지면서 전역상태관리가 잘못 되면서 생기는 사이드 이팩트 또한 줄어 들게 되고, 메모리 점유도 적어지게 되었다.












