# 일급 함수 1


## 일급값 (일급 객체)
함수의 인자로 넘길수 있고, 변수에 할당하수 있으며, 리턴으로 넘길수 있어야함. ( 모든 것은 재사용을 위해서임. )


> 이런 특성을 활용하면 일급 객체(함수)을 제외한 곳을 모듈화 해서 기능을 추상화 할수 있기 때문에 중요한 가치를 가진다.


## Call by value & Call by Name 

함수형 프로그래밍에서 아주아주 중요한 개념 함수가 인자로 전달될 경우, 그즉시 함수를 평가한다.!  (평가 === 실행)
그렇기 떄문에 책에서 나온 값으로의 전달과는 다른 의미를 지닌다.  
프론트엔드에서는 함수의 실행 시점의 데이터의 상태가 중요하기 때문에 이런식으로 언제 함수의 값이 리턴 즉 함수가 평가 되는지에 따라 결과가 달라짐.!!!

아쉬운점. 책에서는 이런 것보다는 try catch 의 예시로 들어 줬음...


함수를 인자로 넘기던 평가된 값을 인자로 넘기던 어떤게 좋은지는 판단할수 없지만, 재사용성 기능 추상화에 있어선 평가된 값보단  
일급 함수가 재사용하기 훨씬 좋은 것은 사실임.

## 고차 함수

함수를 리턴하고, 함수를 인자로 전달 받는 함수.

객체지향과 다른 점은 객체지향도 이런 식으로 처리의 순서 관계를 통해 데이터를 처리할수 있지만

미리 설계된 상속 또는 추상화 상태여야지 되는데, 고차함수는 인자로 받는 함수에 대한 정보를 통해서 하기 떄문에

미리 설계하지 않고 필요한 상황에서 사용할수 있다.

자주 쓰이는곳이 node js 미들웨어에서 쓰인다. 고차 함수를 통해 반복적인 작업을 줄이고, 방어코드를 심을 수 있다.



## 개인 생각

문제점 
- 일급 함수나 고차함수를 통해 기능을 추상화하는것은 좋지만, 단점으로는 가독성이 떨어진다. (이름의 기능적 모호성 때문)
- 이런 문제로 또한 공통화 시켜서 사용할수 있다는 착각에 빠지기 쉽다.
  - 이런 문제를 해결하기 위해서는 일급 객체를 활용해서 나눌때 일급 객체에 대한 의존성을 아예 없애거나 엄청 낮춰야 함.
    - 예시) 비슷한 자료구조를 통한 추상화면 상관 없는데 어떤 일급 객체 인자는 자료구조상 해시맵이고 어떤 것은 배열이면 함수 내부에서 다루기 힘들어진다

이런 문제를 잘 인지하고 짜는게 중요한것 같음.


코틀린을 대충 공부하면서 느낀점.

자바랑 아주 큰 차이가 이부분이였음. 코틀린은 자바와 다르게 

함수에 함수를 인자로 받고 리턴할수 있으며, 변수나 데이터에 할당 가능하다.

그렇기 때문에 코틀린은 자바에 비해서 재사용성을 높이고 좀 더 모던하고 유연하다고 생각했다.
